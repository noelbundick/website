<!doctype html><html lang=en-us><head><title>Serverless VSTS Build Agents with Azure Container Instances | Noel Bundick</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Serverless VSTS Build Agents with Azure Container Instances üîóEvery software project is different, and may rely on wildly different dependencies at build time. Package managers make this go away most of the time, but sometimes there are things you need installed at the OS level to build or run.
Visual Studio Team Services (VSTS) is a great tool that can run your automated builds and offers Hosted Agents where there&rsquo;s quite a bit of useful tooling already installed (check the Linux Dockerfile here)."><meta name=generator content="Hugo 0.99.1"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/custom.css><link rel=stylesheet href=/fontawesome/css/fontawesome.min.css><link rel=stylesheet href=/fontawesome/css/brands.min.css><link rel="shortcut icon" href=/images/favicon.ico type=image/x-icon></head><body><nav class=navigation><a href=/><span class=arrow>‚Üê</span>Home</a>
<a href=/posts>Archive</a>
<a href=/tags>Tags</a></nav><main class=main><section id=single><h1 class=title>Serverless VSTS Build Agents with Azure Container Instances</h1><div class=tip><time datetime="2018-04-22 00:00:00 +0000 UTC">Apr 22, 2018</time>
<span class=split>¬∑</span>
<span>1227 words</span>
<span class=split>¬∑</span>
<span>6 minute read</span></div><aside class=toc><details><summary>Table of Contents</summary><div><nav id=TableOfContents><ul><li><a href=#overview>Overview</a></li><li><a href=#defining-the-build-agent>Defining the Build Agent</a></li><li><a href=#creating-an-agent-pool>Creating an Agent Pool</a></li><li><a href=#yak-shaving-with-azure-functions>Yak Shaving with Azure Functions</a><ul><li><a href=#startvstsbuildagent>StartVSTSBuildAgent</a></li><li><a href=#stopvstsbuildagent>StopVSTSBuildAgent</a></li></ul></li><li><a href=#configuring-vsts-builds>Configuring VSTS Builds</a><ul><li><a href=#process>Process</a></li><li><a href=#agentless-phase---setup>Agentless phase - Setup</a></li><li><a href=#aci-build>ACI Build</a></li><li><a href=#agentless-phase---teardown>Agentless phase - Teardown</a></li></ul></li><li><a href=#summary>Summary</a></li></ul></nav></div></details></aside><div class=content><h1 id=serverless-vsts-build-agents-with-azure-container-instances>Serverless VSTS Build Agents with Azure Container Instances <a href=#serverless-vsts-build-agents-with-azure-container-instances class=anchor>üîó</a></h1><p>Every software project is different, and may rely on wildly different dependencies at build time. Package managers make this go away most of the time, but sometimes there are things you need installed at the OS level to build or run.</p><p><a href=https://www.visualstudio.com/team-services/ target=_blank rel=noopener>Visual Studio Team Services</a> (VSTS) is a great tool that can run your automated builds and offers <a href="https://docs.microsoft.com/en-us/vsts/build-release/concepts/agents/hosted?view=vsts" target=_blank rel=noopener>Hosted Agents</a> where there&rsquo;s quite a bit of useful tooling already installed (check the Linux Dockerfile <a href=%28https://github.com/Microsoft/vsts-agent-docker/blob/master/ubuntu/16.04/standard/Dockerfile%29>here</a>).</p><p>Sometimes, the Hosted Agents won&rsquo;t have the software you need, or you may want a particularly beefy build host. VSTS also lets you bring your own agent, where you can do whatever you want. This is great, but now you need to maintain (read: pay for) a VM that&rsquo;s ready to accept jobs.</p><p>By taking advantage of Azure Container Instances, you can spin up a build agent on-demand that contains whatever you want, while only paying for the seconds of compute and memory time you actually use.</p><blockquote><p>If you&rsquo;re here, you probably like code! The example repo to follow along is <a href=https://github.com/noelbundick/vsts-aci-build-agent target=_blank rel=noopener>https://github.com/noelbundick/vsts-aci-build-agent</a></p></blockquote><h2 id=overview>Overview <a href=#overview class=anchor>üîó</a></h2><p>The zeroth step, not covered in this post, is that I&rsquo;ve written some code and want to build it. I&rsquo;ve pushed it to GitHub. On build, VSTS picks up my commit & launches an automated build. This is where it gets interesting. Here&rsquo;s a big picture of what I&rsquo;ve put together.</p><p><p class=markdown-image><img src=/posts/serverless-vsts-build-agents-with-azure-container-instances/overview.png alt="Overview of on-demand build agents"></p></p><ol><li><p>In an <a href="https://docs.microsoft.com/en-us/vsts/build-release/concepts/process/phases?view=vsts#agentless-phase" target=_blank rel=noopener>Agentless phase</a>, invoke an Azure Function that will create an on-demand build agent via Azure Container Instances in a custom agent pool named <code>AzureContainerInstance</code>.</p></li><li><p>In an <a href="https://docs.microsoft.com/en-us/vsts/build-release/concepts/process/phases?view=vsts#agent-phase" target=_blank rel=noopener>Agent phase</a>, I run my build steps, capture test results, and copy the artifacts I care about back to the VSTS service. These steps target an agent pool named <code>AzureContainerInstance</code>, and are matched up with the container created in step 1.</p></li><li><p>In another Agentless phase, call a second Azure Function to delete the build agent.</p></li></ol><blockquote><p>Note: For simplicity, I&rsquo;m making an implicit assumption that I don&rsquo;t have multiple builds going on at the same time here. You&rsquo;ll want to tweak the process as needed to support concurrent builds.</p></blockquote><h2 id=defining-the-build-agent>Defining the Build Agent <a href=#defining-the-build-agent class=anchor>üîó</a></h2><p>Before we dive into VSTS configuration, we need to define what we want in the build agent. The Hosted Linux agent is actually pretty awesome, but it&rsquo;s also pretty huge. To validate, I&rsquo;m using something extremely stripped down. Debian + git + Python + VSTS agent is all I need today.</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#719e07>FROM</span><span style=color:#2aa198> debian:stretch</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>ARG</span> <span style=color:#268bd2>VSTS_VERSION</span><span style=color:#719e07>=</span><span style=color:#2aa198>2</span>.131.0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>WORKDIR</span><span style=color:#2aa198> /agent</span>
</span></span><span style=display:flex><span><span style=color:#719e07>RUN</span> useradd vsts
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>RUN</span> apt-get update <span style=color:#cb4b16>\
</span></span></span><span style=display:flex><span><span style=color:#cb4b16></span>  <span style=color:#719e07>&amp;&amp;</span> apt-get install -y git python python-setuptools python-pip <span style=color:#cb4b16>\
</span></span></span><span style=display:flex><span><span style=color:#cb4b16></span>  <span style=color:#719e07>&amp;&amp;</span> rm -rf /var/lib/apt/lists/* <span style=color:#cb4b16>\
</span></span></span><span style=display:flex><span><span style=color:#cb4b16></span>  <span style=color:#719e07>&amp;&amp;</span> pip install wheel
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>ADD</span> https://vstsagentpackage.azureedge.net/agent/<span style=color:#268bd2>$VSTS_VERSION</span>/vsts-agent-linux-x64-<span style=color:#268bd2>$VSTS_VERSION</span>.tar.gz .
</span></span><span style=display:flex><span><span style=color:#719e07>RUN</span> tar xzf vsts-agent-linux-x64-<span style=color:#268bd2>$VSTS_VERSION</span>.tar.gz <span style=color:#cb4b16>\
</span></span></span><span style=display:flex><span><span style=color:#cb4b16></span>  <span style=color:#719e07>&amp;&amp;</span> ./bin/installdependencies.sh <span style=color:#cb4b16>\
</span></span></span><span style=display:flex><span><span style=color:#cb4b16></span>  <span style=color:#719e07>&amp;&amp;</span> chown -R vsts:vsts /agent
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>USER</span><span style=color:#2aa198> vsts</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>ENTRYPOINT</span> [<span style=color:#2aa198>&#34;/bin/bash&#34;</span>, <span style=color:#2aa198>&#34;-c&#34;</span>, <span style=color:#2aa198>&#34;./config.sh --unattended --replace &amp;&amp; ./run.sh&#34;</span>]
</span></span></code></pre></div><p>I&rsquo;ve built & pushed this sample to <a href=https://hub.docker.com/r/acanthamoeba/vsts-build-agent/ target=_blank rel=noopener>acanthamoeba/vsts-build-agent</a> on Docker Hub.</p><h2 id=creating-an-agent-pool>Creating an Agent Pool <a href=#creating-an-agent-pool class=anchor>üîó</a></h2><p>I&rsquo;ve also decided to put all my dynamically created build agents in their own pool. This step is optional, but I wanted to keep them all grouped together. To create a new pool:</p><ol><li><p>Go to <code>Settings -> Agent Queues</code></p></li><li><p>Click <code>Manage pools</code> in the left menu</p></li><li><p>Click <code>New pool...</code></p></li><li><p>Give it a name & hit <code>OK</code></p></li></ol><p><p class=markdown-image><img src=/posts/serverless-vsts-build-agents-with-azure-container-instances/create-pool.PNG alt="(optional) Create a new agent pool"></p></p><h2 id=yak-shaving-with-azure-functions>Yak Shaving with Azure Functions <a href=#yak-shaving-with-azure-functions class=anchor>üîó</a></h2><p>VSTS Agentless phases are <strong>very</strong> limited, which makes sense! You&rsquo;re getting a tiny bit of compute for free there, so what you really get is the ability to invoke something else that will do the real work. At the time of this post, VSTS doesn&rsquo;t support invoking an Azure Container Instance or ARM call directly, but it does support Azure Functions! That means with a tiny bit of extra work, I can do whatever I want!</p><p><p class=markdown-image><img src=/posts/serverless-vsts-build-agents-with-azure-container-instances/agentless.PNG alt="Agentless phase build tasks"></p></p><p>I&rsquo;ve set up an Azure Functions app with two functions - <code>StartVSTSBuildAgent</code> and <code>StopVSTSBuildAgent</code>. These functions use Application Settings to know which VSTS instance to connect to, and they use a Service Principal to perform operations in my Subscription. This lets me lock down my function, so that if it were to be compromised in any way, I could quickly revoke access & rotate my secrets.</p><h3 id=startvstsbuildagent>StartVSTSBuildAgent <a href=#startvstsbuildagent class=anchor>üîó</a></h3><p>I used .NET for my function because it&rsquo;s easy & the Azure SDK&rsquo;s are always up-to-date. I already had some other C# functions, so there was no need for anything different. The important code is below</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#719e07>await</span> <span style=color:#2aa198>_</span>azure.ContainerGroups.Define(agentName)
</span></span><span style=display:flex><span>  .WithRegion(resourceGroup.RegionName)
</span></span><span style=display:flex><span>  .WithExistingResourceGroup(resourceGroup)
</span></span><span style=display:flex><span>  .WithLinux()
</span></span><span style=display:flex><span>  .WithPublicImageRegistryOnly()
</span></span><span style=display:flex><span>  .WithoutVolume()
</span></span><span style=display:flex><span>  .DefineContainerInstance(agentName)
</span></span><span style=display:flex><span>      .WithImage(<span style=color:#2aa198>&#34;acanthamoeba/vsts-build-agent&#34;</span>)
</span></span><span style=display:flex><span>      .WithoutPorts()
</span></span><span style=display:flex><span>      .WithEnvironmentVariables(env)
</span></span><span style=display:flex><span>      .Attach()
</span></span><span style=display:flex><span>  .CreateAsync();
</span></span></code></pre></div><blockquote><p>You can find the full source in the <a href=https://github.com/noelbundick/vsts-aci-build-agent target=_blank rel=noopener>noelbundick/vsts-aci-build-agent</a> repo</p></blockquote><h3 id=stopvstsbuildagent>StopVSTSBuildAgent <a href=#stopvstsbuildagent class=anchor>üîó</a></h3><p>Likewise, the stop function, which deletes the container instance is driven by the following line</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#719e07>await</span> <span style=color:#2aa198>_</span>azure.ContainerGroups.DeleteByResourceGroupAsync(<span style=color:#2aa198>&#34;vsts&#34;</span>, agentName);
</span></span></code></pre></div><h2 id=configuring-vsts-builds>Configuring VSTS Builds <a href=#configuring-vsts-builds class=anchor>üîó</a></h2><p>My VSTS build process looks like the following screenshot. Let&rsquo;s walk through each component.</p><p><p class=markdown-image><img src=/posts/serverless-vsts-build-agents-with-azure-container-instances/vsts-build.PNG alt="VSTS build configuration steps"></p></p><h3 id=process>Process <a href=#process class=anchor>üîó</a></h3><p>I want all my Agent phases to run inside my containers, so I&rsquo;ve specified the <code>Agent queue</code></p><p><p class=markdown-image><img src=/posts/serverless-vsts-build-agents-with-azure-container-instances/process.PNG alt="Specifying the agent pool"></p></p><h3 id=agentless-phase---setup>Agentless phase - Setup <a href=#agentless-phase---setup class=anchor>üîó</a></h3><p>This is where I create my build agent. Setting this up was pretty straightforward, though I did play around a bit with the name. I wanted to be able to look at a container instance and identify which app & build number it was for. My simple convention is <code>vsts-agent-&lt;APP>-&lt;BUILD></code>, as shown in the screenshot below.</p><p><p class=markdown-image><img src=/posts/serverless-vsts-build-agents-with-azure-container-instances/create-function.PNG alt="Specifying the agent pool"></p></p><h3 id=aci-build>ACI Build <a href=#aci-build class=anchor>üîó</a></h3><p>Your app will be built differently than mine, so I&rsquo;m not going to dive into too much here. These steps run on my selected agent pool (<code>AzureContainerInstance</code>), inherited from the top-level Process. This will be just like using a Hosted Agent, or some other custom pool you may be accustomed to.</p><p>One item I do need to call out, however, is that this phase has a dependency on the previous phase. In practice, this one isn&rsquo;t strictly necessary - VSTS will hold the job & assign it once an agent is available. However, I ran into a case while testing where the delete phase ran before the build phase&mldr; my container had been created & deleted before a build ever had a chance to run - leaving it stuck.</p><p>Don&rsquo;t be like me - explicitly define your dependencies!</p><p><p class=markdown-image><img src=/posts/serverless-vsts-build-agents-with-azure-container-instances/dependencies.PNG alt="Specifying dependencies"></p></p><h3 id=agentless-phase---teardown>Agentless phase - Teardown <a href=#agentless-phase---teardown class=anchor>üîó</a></h3><p>This is conceptually identical to the setup phase. A couple of things to note in the final step</p><p>First, functions have different keys, so don&rsquo;t this is not the place to exercise your copypasta skills and walk away.</p><p><p class=markdown-image><img src=/posts/serverless-vsts-build-agents-with-azure-container-instances/teardownkey.PNG alt="Don't copypasta keys!"></p></p><p>Second, you did remember my note about dependencies, right? This one is more important than the first</p><p><p class=markdown-image><img src=/posts/serverless-vsts-build-agents-with-azure-container-instances/returnofthedependencies.PNG alt="Dependencies everywhere!"></p></p><h2 id=summary>Summary <a href=#summary class=anchor>üîó</a></h2><p>That was pretty painless! A little bit of hassle, but that&rsquo;s just of the nature of CI/CD configuration in my experience. I&rsquo;m going back and forth on where I&rsquo;d use this over just including a Dockerfile & using a Hosted agent pool. If you know your build needs a lot of dedicated CPU & memory in a funky environment, this might be a neat tool to keep in your belt.</p><p>You should be able to tweak this process to use with Windows containers if you need a dynamic Windows pool as well. Keep an eye out for the differences between Windows Server 2016, version 1709, etc. and what&rsquo;s supported by Azure Container Instances. Ex: if you need to execute on Insider builds of Windows Server, this solution probably isn&rsquo;t for you.</p><p>Finally, I&rsquo;m not even close to the first one to think of or implement VSTS agents on Azure Container Instances. Do a quick search, and you&rsquo;ll find a ton of great ideas & posts out there. Hope you&rsquo;ve found this one useful!</p></div><div class=tags><a href=/tags/aci>aci</a>
<a href=/tags/azure>azure</a>
<a href=/tags/vsts>vsts</a></div></section></main><section><ul class=post-list><li>2021-10-14
<a href=/gists/optimizing-rust-container-builds/>Optimizing Rust container builds<h2></h2></a></li><li>2021-09-19
<a href=/gists/wsl2-container-development-with-moby/>WSL2 container development with Moby<h2></h2></a></li><li>2019-12-17
<a href=/gists/rdp-from-wsl/>RDP from WSL<h2></h2></a></li><li>2019-06-28
<a href=/gists/how-to-use-docker-build-secrets/>How to use Docker build secrets<h2></h2></a></li><li>2019-06-12
<a href=/gists/consuming-packages-from-a-private-azure-pipelines-python-artifact-feed/>Consuming packages from a private Azure Pipelines Python artifact feed<h2></h2></a></li><li>2019-01-13
<a href=/gists/gists-as-a-content-management-system/>Gists as a content management system<h2></h2></a></li><li>2019-01-12
<a href=/gists/azure-function-w--user-assigned-identity/>Azure Function w/ User Assigned Identity<h2></h2></a></li><li>2018-12-15
<a href=/gists/secure-code-execution-via-arm-template-and-azure-container-instances/>Secure code execution via ARM template and Azure Container Instances<h2></h2></a></li><li>2018-12-10
<a href=/gists/azure-redis-cli/>azure-redis-cli<h2></h2></a></li><li>2018-12-10
<a href=/gists/resize-azure-cloud-shell-storage/>Resize Azure Cloud Shell storage<h2></h2></a></li></ul></section><footer id=footer><div id=social><a class=symbol href=https://www.github.com/noelbundick><i class="fa-brands fa-github"></i></a>
<a class=symbol href=https://www.linkedin.com/in/noelbundick/><i class="fa-brands fa-linkedin"></i></a>
<a class=symbol href=https://twitter.com/acanthamoeba><i class="fa-brands fa-twitter"></i></a></div><div class=copyright>¬© Copyright
2022
<span class=split><svg fill="#bbb" width="15" height="15" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 0 15 15"><path d="M13.91 6.75c-1.17 2.25-4.3 5.31-6.07 6.94-.1903.1718-.4797.1718-.67.0C5.39 12.06 2.26 9 1.09 6.75-1.48 1.8 5-1.5 7.5 3.45 10-1.5 16.48 1.8 13.91 6.75z"/></svg></span>Noel Bundick</div></footer></body></html>